<!DOCTYPE html>
<html lang="es">
	<head>
		<title>MIWEB</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>
	<body>

		<div id="overlay">
			<button id="startButton">Play</button>
			<div id="carga"></div>
		</div>

		<div id="container"></div>

		<audio loop id="music" preload="auto" style="display: none">
			<source src="sounds/universo.mp3" type="audio/mpeg">
		</audio>

		<video id="video" loop muted crossOrigin="anonymous" playsinline style="display:none">
			<source src="./videos/galax.mp4">
		</video>
		
		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.webgpu.js",
					"three/webgpu": "./build/three.webgpu.js",
					"three/tsl": "./build/three.tsl.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">

			import * as THREE from 'three';
			import { atan, cos, float, max, min, mix, PI, PI2, sin, vec2, vec3, color, Fn, hash, hue, If, instanceIndex, Loop, mx_fractal_noise_float, mx_fractal_noise_vec3, pass, pcurve, storage, deltaTime, time, uv, uniform, mrt, output, emissive } from 'three/tsl';
			import { bloom } from 'three/addons/tsl/display/BloomNode.js';
            import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
			import { PositionalAudioHelper } from 'three/addons/helpers/PositionalAudioHelper.js';
			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
			import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
			
			let camera, scene, renderer, postProcessing, controls, clock;
			let updateParticles, spawnParticles; // TSL compute nodes
			let getInstanceColor; // TSL function
			let INTERSECTED;
			let esferas;
			let video;
			let meshu;
			let mixer;
			//let mixer1;
			
			const screenPointer = new THREE.Vector2();
			const scenePointer = new THREE.Vector3();
			const raycastPlane = new THREE.Plane( new THREE.Vector3( 0, 0, 1 ), 0 );
			const raycaster = new THREE.Raycaster();
			const nbParticles = Math.pow( 2, 8 );
			const timeScale = uniform( 1.0 );
			const particleLifetime = uniform( 0.05 );
			const particleSize = uniform( 1.0 );
			const linksWidth = uniform( 0.005 );
			const colorOffset = uniform( 0.0 );
			const colorVariance = uniform( 2.0 );
			const colorRotationSpeed = uniform( 1.0 );
			const spawnIndex = uniform( 0 );
			const nbToSpawn = uniform( 5 );
			const spawnPosition = uniform( vec3( 0.0 ) );
			const previousSpawnPosition = uniform( vec3( 0.0 ) );
			const turbFrequency = uniform( 0.5 );
			const turbAmplitude = uniform( 0.5 );
			const turbOctaves = uniform( 2 );
			const turbLacunarity = uniform( 2.0 );
			const turbGain = uniform( 0.5 );
			const turbFriction = uniform( 0.01 );

			const startButton = document.getElementById( 'startButton' );
			startButton.addEventListener( 'click', init );

			function init() {

				const overlay = document.getElementById( 'overlay' );
				overlay.remove();

				const container = document.getElementById( 'container' );

				camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( 0, 4, 12 );

				scene = new THREE.Scene();
				
				clock = new THREE.Clock();
				
				const listener = new THREE.AudioListener();
				camera.add( listener );

				const audioElement = document.getElementById( 'music' );
				audioElement.play();

				const positionalAudio = new THREE.PositionalAudio( listener );
				positionalAudio.setMediaElementSource( audioElement );
				positionalAudio.setRefDistance( 2 );
				positionalAudio.setDirectionalCone( 360, 360, 0.1 );

				//universo

				video = document.getElementById( 'video' );
				video.play();
				const universo = new THREE.SphereGeometry( 4, 64, 32 );
				universo.scale( - 8, 8, 8 );
				const textureu = new THREE.VideoTexture( video );
				const materialu = new THREE.MeshLambertMaterial( { map: textureu } );
				meshu = new THREE.Mesh( universo, materialu );
				meshu.position.set(0, 0, 0 );
				scene.add( meshu );

				//modelos

				const rgbeLoader = new RGBELoader();

				rgbeLoader.load('./textures/royal_esplanade_1k.hdr', function(texture) {
					texture.mapping = THREE.EquirectangularReflectionMapping;
					scene.environment = texture;
					
					const loader = new GLTFLoader().setPath( 'INICIO/' );
					loader.setDRACOLoader( new DRACOLoader().setDecoderPath( 'jsm/libs/draco/gltf/' ) );
					loader.load( '4FINAL.glb', function ( gltf ) {

						const model = gltf.scene;

						model.add( positionalAudio );
						model.position.set(0, -2, 0);
						model.scale.set(0.35, 0.35, 0.35);
						scene.add( model );

						mixer = new THREE.AnimationMixer( model );
						mixer.clipAction( gltf.animations[ 0 ] ).play();
				
						renderer.setAnimationLoop( animate );

					} );
				
					/*const loader1 = new GLTFLoader().setPath( 'particulas/' );
					loader1.load( 'particulas.gltf', async function ( gltf ) {

						const model1 = gltf.scene;

						await renderer.compileAsync( model1, camera, scene );

						model1.add( positionalAudio );
						model1.position.set(0, -1, 0);
						model1.scale.set(0.35, 0.35, 0.35);
						scene.add( model1 );

						mixer1 = new THREE.AnimationMixer( model1 );
						mixer1.clipAction( gltf.animations[ 0 ] ).play();
				
						renderer.setAnimationLoop( animate );

					} );*/

				} );

				renderer = new THREE.WebGPURenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.setAnimationLoop( animate );
				renderer.toneMapping = THREE.ACESFilmicToneMapping;
				container.appendChild( renderer.domElement );

				// TSL function
				// current color from index
				getInstanceColor = /*#__PURE__*/ Fn( ( [ i ] ) => {

					return hue( color( 0x0000ff ), colorOffset.add( mx_fractal_noise_float( i.toFloat().mul( .1 ), 2, 2.0, 0.5, colorVariance ) ) );

				} );

				// Particles
				// storage buffers
				const particlePositions = storage( new THREE.StorageInstancedBufferAttribute( nbParticles, 4 ), 'vec4', nbParticles );
				const particleVelocities = storage( new THREE.StorageInstancedBufferAttribute( nbParticles, 4 ), 'vec4', nbParticles );

				// init particles buffers
				renderer.computeAsync( /*#__PURE__*/ Fn( () => {

					particlePositions.element( instanceIndex ).xyz.assign( vec3( 10000.0 ) );
					particlePositions.element( instanceIndex ).w.assign( vec3( - 1.0 ) ); // life is stored in w component; x<0 means dead

				} )().compute( nbParticles ) );

				// particles output
				const particleQuadSize = 0.05;
				const particleGeom = new THREE.PlaneGeometry( particleQuadSize, particleQuadSize );

				const particleMaterial = new THREE.SpriteNodeMaterial();
				particleMaterial.blending = THREE.AdditiveBlending;
				particleMaterial.depthWrite = false;
				particleMaterial.positionNode = particlePositions.toAttribute();
				particleMaterial.scaleNode = vec2( particleSize );
				particleMaterial.rotationNode = atan( particleVelocities.toAttribute().y, particleVelocities.toAttribute().x );

				particleMaterial.colorNode = /*#__PURE__*/ Fn( () => {

					const life = particlePositions.toAttribute().w;
					const modLife = pcurve( life.oneMinus(), 8.0, 1.0 );
					const pulse = pcurve(
						sin( hash( instanceIndex ).mul( PI2 ).add( time.mul( 0.5 ).mul( PI2 ) ) ).mul( 0.5 ).add( 0.5 ),
						0.25,
						0.25
					).mul( 10.0 ).add( 1.0 );

					return getInstanceColor( instanceIndex ).mul( pulse.mul( modLife ) );

				} )();

				particleMaterial.opacityNode = /*#__PURE__*/ Fn( () => {

					const circle = uv().xy.sub( 0.5 ).length().step( 0.5 );
					const life = particlePositions.toAttribute().w;

					return circle.mul( life );

				} )();

				const particleMesh = new THREE.InstancedMesh( particleGeom, particleMaterial, nbParticles );
				particleMesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage );
				particleMesh.frustumCulled = false;

				scene.add( particleMesh );

				const linksIndices = [];
				for ( let i = 0; i < nbParticles; i ++ ) {

					const baseIndex = i * 8;
					for ( let j = 0; j < 2; j ++ ) {

						const offset = baseIndex + j * 4;
						linksIndices.push( offset, offset + 1, offset + 2, offset, offset + 2, offset + 3 );

					}

				}

				// storage buffers attributes for the links
				const nbVertices = nbParticles * 8;
				const linksVerticesSBA = new THREE.StorageBufferAttribute( nbVertices, 4 );
				const linksColorsSBA = new THREE.StorageBufferAttribute( nbVertices, 4 );

				// links output
				const linksGeom = new THREE.BufferGeometry();
				linksGeom.setAttribute( 'position', linksVerticesSBA );
				linksGeom.setAttribute( 'color', linksColorsSBA );
				linksGeom.setIndex( linksIndices );

				const linksMaterial = new THREE.MeshBasicNodeMaterial();
				linksMaterial.vertexColors = true;
				linksMaterial.side = THREE.DoubleSide;
				linksMaterial.transparent = true;
				linksMaterial.depthWrite = false;
				linksMaterial.depthTest = false;
				linksMaterial.blending = THREE.AdditiveBlending;
				linksMaterial.opacityNode = storage( linksColorsSBA, 'vec4', linksColorsSBA.count ).toAttribute().w;

				const linksMesh = new THREE.Mesh( linksGeom, linksMaterial );
				linksMesh.frustumCulled = false;
				scene.add( linksMesh );

				// compute nodes
				updateParticles = /*#__PURE__*/ Fn( () => {

					const position = particlePositions.element( instanceIndex ).xyz;
					const life = particlePositions.element( instanceIndex ).w;
					const velocity = particleVelocities.element( instanceIndex ).xyz;
					const dt = deltaTime.mul( 0.1 ).mul( timeScale );

					If( life.greaterThan( 0.0 ), () => {

						// first we update the particles positions and velocities
						// velocity comes from a turbulence field, and is multiplied by the particle lifetime so that it slows down over time
						const localVel = mx_fractal_noise_vec3( position.mul( turbFrequency ), turbOctaves, turbLacunarity, turbGain, turbAmplitude ).mul( life.add( .01 ) );
						velocity.addAssign( localVel );
						velocity.mulAssign( turbFriction.oneMinus() );
						position.addAssign( velocity.mul( dt ) );

						// then we decrease the lifetime
						life.subAssign( dt.mul( particleLifetime.reciprocal() ) );

						// then we find the two closest particles and set a quad to each of them
						const closestDist1 = float( 10000.0 ).toVar();
						const closestPos1 = vec3( 0.0 ).toVar();
						const closestLife1 = float( 0.0 ).toVar();
						const closestDist2 = float( 10000.0 ).toVar();
						const closestPos2 = vec3( 0.0 ).toVar();
						const closestLife2 = float( 0.0 ).toVar();

						Loop( nbParticles, ( { i } ) => {

							const otherPart = particlePositions.element( i );

							If( i.notEqual( instanceIndex ).and( otherPart.w.greaterThan( 0.0 ) ), () => { // if not self and other particle is alive

								const otherPosition = otherPart.xyz;
								const dist = position.sub( otherPosition ).lengthSq();
								const moreThanZero = dist.greaterThan( 0.0 );

								If( dist.lessThan( closestDist1 ).and( moreThanZero ), () => {

									closestDist1.assign( dist );
									closestPos1.assign( otherPosition.xyz );
									closestLife1.assign( otherPart.w );

								} ).ElseIf( dist.lessThan( closestDist2 ).and( moreThanZero ), () => {

									closestDist2.assign( dist );
									closestPos2.assign( otherPosition.xyz );
									closestLife2.assign( otherPart.w );

								} );

							} );

						} );

						// then we update the links correspondingly
						const linksPositions = storage( linksVerticesSBA, 'vec4', linksVerticesSBA.count );
						const linksColors = storage( linksColorsSBA, 'vec4', linksColorsSBA.count );
						const firstLinkIndex = instanceIndex.mul( 8 );
						const secondLinkIndex = firstLinkIndex.add( 4 );

						// positions link 1
						linksPositions.element( firstLinkIndex ).xyz.assign( position );
						linksPositions.element( firstLinkIndex ).y.addAssign( linksWidth );
						linksPositions.element( firstLinkIndex.add( 1 ) ).xyz.assign( position );
						linksPositions.element( firstLinkIndex.add( 1 ) ).y.addAssign( linksWidth.negate() );
						linksPositions.element( firstLinkIndex.add( 2 ) ).xyz.assign( closestPos1 );
						linksPositions.element( firstLinkIndex.add( 2 ) ).y.addAssign( linksWidth.negate() );
						linksPositions.element( firstLinkIndex.add( 3 ) ).xyz.assign( closestPos1 );
						linksPositions.element( firstLinkIndex.add( 3 ) ).y.addAssign( linksWidth );

						// positions link 2
						linksPositions.element( secondLinkIndex ).xyz.assign( position );
						linksPositions.element( secondLinkIndex ).y.addAssign( linksWidth );
						linksPositions.element( secondLinkIndex.add( 1 ) ).xyz.assign( position );
						linksPositions.element( secondLinkIndex.add( 1 ) ).y.addAssign( linksWidth.negate() );
						linksPositions.element( secondLinkIndex.add( 2 ) ).xyz.assign( closestPos2 );
						linksPositions.element( secondLinkIndex.add( 2 ) ).y.addAssign( linksWidth.negate() );
						linksPositions.element( secondLinkIndex.add( 3 ) ).xyz.assign( closestPos2 );
						linksPositions.element( secondLinkIndex.add( 3 ) ).y.addAssign( linksWidth );

						// colors are the same for all vertices of both quads
						const linkColor = getInstanceColor( instanceIndex );

						// store the minimum lifetime of the closest particles in the w component of colors
						const l1 = max( 0.0, min( closestLife1, life ) ).pow( 0.8 ); // pow is here to apply a slight curve to the opacity
						const l2 = max( 0.0, min( closestLife2, life ) ).pow( 0.8 );

						Loop( 4, ( { i } ) => {

							linksColors.element( firstLinkIndex.add( i ) ).xyz.assign( linkColor );
							linksColors.element( firstLinkIndex.add( i ) ).w.assign( l1 );
							linksColors.element( secondLinkIndex.add( i ) ).xyz.assign( linkColor );
							linksColors.element( secondLinkIndex.add( i ) ).w.assign( l2 );

						} );

					} );

				} )().compute( nbParticles );

				spawnParticles = /*#__PURE__*/ Fn( () => {

					const particleIndex = spawnIndex.add( instanceIndex ).mod( nbParticles ).toInt();
					const position = particlePositions.element( particleIndex ).xyz;
					const life = particlePositions.element( particleIndex ).w;
					const velocity = particleVelocities.element( particleIndex ).xyz;

					life.assign( 1.0 ); // sets it alive

					// random spherical direction
					const rRange = float( 0.01 );
					const rTheta = hash( particleIndex ).mul( PI2 );
					const rPhi = hash( particleIndex.add( 1 ) ).mul( PI );
					const rx = sin( rTheta ).mul( cos( rPhi ) );
					const ry = sin( rTheta ).mul( sin( rPhi ) );
					const rz = cos( rTheta );
					const rDir = vec3( rx, ry, rz );

					// position is interpolated between the previous cursor position and the current one over the number of particles spawned
					const pos = mix( previousSpawnPosition, spawnPosition, instanceIndex.toFloat().div( nbToSpawn.sub( 1 ).toFloat() ).clamp() );
					position.assign( pos.add( rDir.mul( rRange ) ) );

					// start in that direction
					velocity.assign( rDir.mul( 5.0 ) );

				} )().compute( nbToSpawn.value );

				// light for the background

				const ambientLight = new THREE.AmbientLight(0xffffff, 1);
				ambientLight.receiveShadow = true;
				scene.add(ambientLight);
				
				// post processing

				postProcessing = new THREE.PostProcessing( renderer );

				const scenePass = pass( scene, camera );

				scenePass.setMRT( mrt( {
					output,
					emissive
				} ) );

				const outputPass = scenePass.getTextureNode();
				const emissivePass = scenePass.getTextureNode( 'emissive' );

				const scenePassColor = scenePass.getTextureNode( 'output' );

				const bloomPass = bloom( scenePassColor, 0.8, 0.8, 1 , emissivePass, 0.8, .5 );
				
				postProcessing.outputNode = scenePassColor.add( bloomPass );
				postProcessing.outputNode = outputPass.add( bloomPass );

				// controls

				controls = new OrbitControls( camera, renderer.domElement );
				controls.enableDamping = true;
				controls.enablePan = false;
				controls.target.set( 0, 0, 0 );
				controls.minDistance = 1;
				controls.maxDistance = 20;
				controls.saveState()
				window.addEventListener( 'resize', onWindowResize );

				// pointer handling

				window.addEventListener( 'pointermove', onPointerMove );
				window.addEventListener('mousedown', onMouseDown);

				// GUI

			}	

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onPointerMove( e ) {

				screenPointer.x = ( e.clientX / window.innerWidth ) * 2 - 1;
				screenPointer.y = - ( e.clientY / window.innerHeight ) * 2 + 1;
				
			}

			function updatePointer() {

				raycaster.setFromCamera( screenPointer, camera );
				raycaster.ray.intersectPlane( raycastPlane, scenePointer );

			}

			function onMouseDown(event) {
				
				const coords = new THREE.Vector2(
					
					(event.clientX / renderer.domElement.clientWidth) * 2 - 1,
					-((event.clientY / renderer.domElement.clientHeight) * 2 - 1),
				);

				raycaster.setFromCamera(coords, camera);

				const intersections = raycaster.intersectObjects( scene.children, true);

				if ( intersections[0].object.name == 'Esfera1') {
					//  Redirigir a youtube
					window.open("https://www.youtube.com/channel/UCxOZKx6QQQjWdG8Lsg7N9mQ") ;
					controls.reset()
				}
				if ( intersections[0].object.name == 'Esfera2') {
					//  Redirigir a instagram
					window.open("https://www.instagram.com/") ;
					controls.reset()
				}
				if ( intersections[0].object.name == 'Esfera3') {
					//  Redirigir a tiktok
					window.open("https://www.tiktok.com/@etipozo?_t=ZN-8ydDXrHgeEp&_r=1") ;
					controls.reset()
				}
				if ( intersections[0].object.name == 'Esfera4') {
					//  Redirigir a configuracion
					window.open("https://www.tiktok.com/@etipozo?_t=ZN-8ydDXrHgeEp&_r=1") ;
					controls.reset()
				}
				if ( intersections[0].object.name == 'Esfera5') {
					//  Redirigir a wasap
					window.open("https://wa.me/34643084215") ;
					controls.reset()
				}
				if ( intersections[0].object.name == 'Esfera6') {
					//  Redirigir a googlemap
					window.open("https://www.google.com/maps/place/C.+del+Cabo+de+Tarifa,+94,+Puente+de+Vallecas,+28053+Madrid/@40.3707987,-3.6627152,726m/data=!3m1!1e3!4m6!3m5!1s0xd42242a5b22d267:0x77a6e4b054dc4a9d!8m2!3d40.3703964!4d-3.6606136!16s%2Fg%2F11c2ddk4yp?entry=ttu&g_ep=EgoyMDI1MDcyMC4wIKXMDSoASAFQAw%3D%3D") ;
					controls.reset()
				}
				if ( intersections[0].object.name == 'Esfera7') {
					//  Redirigir a facebook
					window.open("https://www.facebook.com/login.php") ;
					controls.reset()
				}
				if ( intersections[0].object.name == 'Esfera8') {
					//  Redirigir a inicio
					window.open("https://www.google.com/imgres?q=inicio&imgurl=https%3A%2F%2Fdeconceptos.com%2Fwp-content%2Fuploads%2F2014%2F07%2Fconcepto-de-inicio.jpg&imgrefurl=https%3A%2F%2Fdeconceptos.com%2Fgeneral%2Finicio&docid=OethzoIXUbaKhM&tbnid=RI1L8or9p74jPM&vet=12ahUKEwjpgOLf9NiOAxWNKvsDHStoKh0QM3oECBgQAA..i&w=267&h=189&hcb=2&ved=2ahUKEwjpgOLf9NiOAxWNKvsDHStoKh0QM3oECBgQAA") ;
					controls.reset()
				}
			}

			function animate() {
				
				const dt = clock.getDelta();
				if ( mixer ) mixer.update( dt / 3 );
				//if ( mixer1 ) mixer1.update( dt * 6 );

				// compute particles
				renderer.compute( updateParticles );
				renderer.compute( spawnParticles );

				// update particle index for next spawn
				spawnIndex.value = ( spawnIndex.value + nbToSpawn.value ) % nbParticles;

				// update raycast plane to face camera
				raycastPlane.normal.applyEuler( camera.rotation );
				updatePointer();

				// lerping spawn position
				previousSpawnPosition.value.copy( spawnPosition.value );
				spawnPosition.value.lerp( scenePointer, 0.1 );

				controls.update();
				postProcessing.render();
				
			}
			
		</script>
	</body>


</html>
